<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta http-equiv="Content-Type: text/html; charset=utf-8"/>
    <title>Estrutura e Interpretação de Programas de Computador</title>
    <link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default"/>
  </head>
  <body>



<a name="%_chap_1" id="%_chap_1"/>
<h1 class="chapter">
<div class="chapterheading"><a href="book-Z-H-4.html#%_toc_%_chap_1">Capítulo 1</a></div></h1><p>
<a href="book-Z-H-4.html#%_toc_%_chap_1">Construindo abstrações com procedimentos</a></p><p>

</p><p>
</p><div align="right">
<table width="60%"><tr><td>
<span class="epigraph">
<p>Os atos da mente, nos quais exerce seu poder sobre ideias simples, são principalmente os três: 1. Combinando várias ideias simples em uma composta, e assim todas as ideias complexas são feitas. 2. A segunda é reunir duas ideias, simples ou complexas, e defini-las uma à outra para poder vê-las de uma só vez, sem uni-las em uma, pela qual obtém todas as ideias de relações. 3. O terceiro está separando-os de todas as outras ideias que os acompanham em sua existência real: isso é chamado de abstração e, portanto, todas as suas ideias gerais são feitas.</p><p>

<a name="%_idx_6" id="%_idx_6"/>John Locke, <em>Um ensaio sobre o entendimento humano</em> (1690)</p><p>

</p></span>
</td></tr></table></div>

<p/><p>Estamos prestes a estudar a ideia de um <a name="%_idx_8" id="%_idx_8"/><a name="%_idx_10" id="%_idx_10"/><em>processo computacional</em>. Processos computacionais são seres abstratos que habitam computadores. À medida que evoluem, os processos manipulam outros objetos abstratos chamados <a name="%_idx_12" id="%_idx_12"/><em>dados</em>. A evolução de um processo é orientado por um padrão de regras chamado <a name="%_idx_14" id="%_idx_14"/><em>programa</em>. As pessoas criam programas para direcionar processos. Com efeito, conjuramos os espíritos do computador com nossos feitiços.</p><p>Um processo computacional é realmente muito parecido com a ideia de espírito de um feiticeiro. Não pode ser visto ou tocado. Não é composto de matéria. No entanto, é muito real. Pode realizar trabalho intelectual. Pode responder a perguntas. Isso pode afetar o mundo desembolsando dinheiro em um banco ou controlando um braço de robô em uma fábrica. Os programas que usamos para conjurar processos são como os feitiços de um feiticeiro. Eles são cuidadosamente compostos a partir de expressões simbólicas em <a name="%_idx_16" id="%_idx_16"/><em>linguagens de programação arcanas e esotéricas</em> que prescrevem as tarefas que queremos que nossos processos executem.</p><p>Um processo computacional, em um computador funcionando corretamente, executa programas com precisão e acurácia. Assim, como o aprendiz de feiticeiro, os programadores iniciantes precisam aprender a entender e antecipar as consequências de sua conjuração. Mesmo pequenos erros (geralmente chamados de <a name="%_idx_18" id="%_idx_18"/><em>erros</em> ou <a name="%_idx_20" id="%_idx_20"/><em>falhas</em>) nos programas podem ter consequências complexas e imprevistas.</p><p>Felizmente, aprender a programar é consideravelmente menos perigoso do que aprender feitiçaria, porque os espíritos com os quais lidamos estão convenientemente contidos de maneira segura. A programação no mundo real, no entanto, requer cuidado, conhecimento e sabedoria. Um pequeno erro em um programa de projeto auxiliado por computador, por exemplo, pode levar ao colapso catastrófico de um avião ou represa ou à autodestruição de um robô industrial.</p><p>Os mestres engenheiros de software possuem a capacidade de organizar programas para que possam ter certeza razoável de que os processos resultantes executarão as tarefas pretendidas. Eles podem visualizar o comportamento de seus sistemas com antecedência. Eles sabem como estruturar programas para que problemas imprevistos não levem a consequências catastróficas e, quando surgem problemas, eles podem <a name="%_idx_22" id="%_idx_22"/><em>depurar</em> seus programas. Sistemas computacionais, como automóveis ou reatores nucleares bem projetados, são projetados de maneira modular, para que as peças possam ser construídas, substituídas e depuradas separadamente.</p><p>

<a name="%_sec_Temp_6" id="%_sec_Temp_6"/>
</p><h4><a href="book-Z-H-4.html#%_toc_%_sec_Temp_6">Programação em Lisp</a></h4><p>Precisamos de uma linguagem apropriada para descrever processos e usaremos para esse fim a linguagem de programação Lisp. Assim como nossos pensamentos cotidianos geralmente são expressos em nossa linguagem natural (como inglês, português ou japonês) e as descrições de fenômenos quantitativos são expressas com notações matemáticas, nossos pensamentos procedimentais serão expressos em Lisp. O<a name="%_idx_24" id="%_idx_24"/> Lisp foi inventado no final da década de 1950 como um formalismo para raciocinar sobre o uso de certos tipos de expressões lógicas, chamadas <a name="%_idx_26" id="%_idx_26"/><em>equações de recursão</em>, como modelo para computação. A linguagem foi concebida por <a name="%_idx_28" id="%_idx_28"/>John McCarthy e é baseada em seu artigo &quot;Recursive Functions of Symbolic Expressions and Their Computation by Machine&quot; (McCarthy, 1960).</p><p>Apesar de sua criação como formalismo matemático, o Lisp é uma linguagem de programação prática. Um <a name="%_idx_30" id="%_idx_30"/><em>interpretador</em> Lisp é uma máquina que executa os processos descritos na linguagem Lisp. O primeiro interpretador Lisp foi implementado por <a name="%_idx_32" id="%_idx_32"/>McCarthy com a ajuda de colegas e estudantes do Grupo de Inteligência Artificial do Laboratório de Pesquisa em Eletrônica<a name="%_idx_34" id="%_idx_34"/> e no Centro de Computação do MIT.<a name="call_footnote_Temp_7" href="#footnote_Temp_7" id="call_footnote_Temp_7"><sup><small>1</small></sup></a> <a name="%_idx_38" id="%_idx_38"/>Lisp, cujo nome é um acrônimo para LISt Processing, foi projetado para fornecer recursos de manipulação de símbolos para atacar problemas de programação, como diferenciação simbólica e integração de álgebra expressões. Incluiu para esse fim novos objetos de dados conhecidos como átomos e listas, que o diferenciam de maneira impressionante de todas as outras linguagens do período.</p><p>Lisp não foi o produto de um esforço de projeto concertado. Em vez disso, evoluiu informalmente de maneira experimental, em resposta às necessidades dos usuários e a considerações pragmáticas da implementação. A evolução informal do Lisp continuou ao longo dos anos, e a comunidade de usuários do Lisp tradicionalmente resistiu às tentativas de promulgar qualquer definição &quot;oficial&quot; da linguagem. Essa evolução, com a flexibilidade e a elegância da concepção inicial, permitiu que o Lisp, que é a segunda linguagem mais antiga hoje em uso generalizado (apenas <a name="%_idx_40" id="%_idx_40"/>Fortran é mais antigo), se adapte continuamente para abranger as ideias mais modernas sobre o programa Projeto. Portanto, o Lisp é agora uma família de dialetos que, embora compartilhem a maioria dos recursos originais, podem diferir um do outro de maneiras significativas. O dialeto do Lisp usado neste livro é chamado <a name="%_idx_42" id="%_idx_42"/><a name="%_idx_44" id="%_idx_44"/>Scheme.<a name="call_footnote_Temp_8" href="#footnote_Temp_8" id="call_footnote_Temp_8"><sup><small>2</small></sup></a></p><p>Devido ao seu caráter experimental e à ênfase na manipulação de símbolos, o <a name="%_idx_96" id="%_idx_96"/><a name="%_idx_98" id="%_idx_98"/><a name="%_idx_100" id="%_idx_100"/>Lisp foi inicialmente muito ineficiente para cálculos numéricos, pelo menos, em comparação com Fortran. Ao longo dos anos, no entanto, os compiladores Lisp foram desenvolvidos para converter programas em código de máquina que podem executar cálculos numéricos razoavelmente eficientemente. E para aplicações especiais, o Lisp foi usado com grande eficácia.<a name="call_footnote_Temp_9" href="#footnote_Temp_9" id="call_footnote_Temp_9"><sup><small>3</small></sup></a> Embora o Lisp ainda não tenha superado sua antiga reputação de irremediavelmente ineficiente, o Lisp é agora usado em muitas aplicações em que a eficiência não é a preocupação central. Por exemplo, o Lisp se tornou uma linguagem de escolha para linguagens shell do sistema operacional e para linguagens de extensão para editores e sistemas de projeto auxiliados por computador.</p><p>Se o Lisp não é uma linguagem convencional, por que a usamos como estrutura para nossa discussão sobre programação? Porque a linguagem possui <a name="%_idx_112" id="%_idx_112"/>características únicas que a tornam um excelente meio para estudar importantes construções de programação e estruturas de dados e relacioná-las com as características linguísticas que as suportam. O mais significativo desses recursos é o fato de que as descrições de processos do Lisp, chamadas <a name="%_idx_114" id="%_idx_114"/><a name="%_idx_116" id="%_idx_116"/><em>procedimentos</em>, podem ser representadas e manipuladas como dados do Lisp. A importância disso é que existem técnicas poderosas de projeto de programas que dependem da capacidade de desfocar a distinção tradicional entre dados &quot;passivos&quot; e processos &quot;ativos&quot;. Como descobriremos, a flexibilidade do Lisp no manuseio de procedimentos como dados o torna uma das linguagens mais convenientes existentes para explorar essas técnicas. A capacidade de representar procedimentos como dados também torna o Lisp uma excelente linguagem para escrever programas que precisam manipular outros programas como dados, como interpretadores e compiladores que suportam linguagens de computador. Acima e além dessas considerações, a programação no Lisp é muito divertida.</p><p>

</p><p/><div class="smallprint"><hr/></div><p>
</p><div class="footnote"><p><a name="footnote_Temp_7" href="#call_footnote_Temp_7" id="footnote_Temp_7"><sup><small>1</small></sup></a> O <em>Lisp 1 Programmer's Manual</em> apareceu em 1960, e o <em>Lisp 1.5 Programmer's Manual</em> <a name="%_idx_36" id="%_idx_36"/>(McCarthy 1965) foi publicado em 1962. A história inicial de Lisp é descrita em McCarthy 1978.</p><p><a name="footnote_Temp_8" href="#call_footnote_Temp_8" id="footnote_Temp_8"><sup><small>2</small></sup></a> Os dois dialetos em que a maioria dos principais programas Lisp da década de 1970 foram escritos são <a name="%_idx_46" id="%_idx_46"/><a name="%_idx_48" id="%_idx_48"/>MacLisp<a name="%_idx_50" id="%_idx_50"/> (Moon 1978; <a name="%_idx_52" id="%_idx_52"/>Pitman 1983), desenvolvido no <a name="%_idx_54" id="%_idx_54"/>Projeto MIT MAC e <a name="%_idx_56" id="%_idx_56"/><a name="%_idx_58" id="%_idx_58"/>Interlisp <a name="%_idx_60" id="%_idx_60"/>(Teitelman 1974), desenvolvido em <a name="%_idx_62" id="%_idx_62"/>Bolt Beranek e Newman Inc. e no <a name="%_idx_64" id="%_idx_64"/>Centro de Pesquisa Xerox Palo Alto. <a name="%_idx_66" id="%_idx_66"/><a name="%_idx_68" id="%_idx_68"/> Portable Standard Lisp<a name="%_idx_70" id="%_idx_70"/> (Hearn 1969; <a name="%_idx_72" id="%_idx_72"/>Griss 1981) era um dialeto Lisp projetado para ser facilmente portátil entre máquinas diferentes. O MacLisp gerou vários subdialectos, como <a name="%_idx_74" id="%_idx_74"/><a name="%_idx_76" id="%_idx_76"/>Franz Lisp, desenvolvido na <a name="%_idx_78" id="%_idx_78"/>&gt;University of California em Berkeley, e <a name="%_idx_80" id="%_idx_80"/><a name="%_idx_82" id="%_idx_82"/>Zetalisp (Moon 1981), que foi baseado em um processador de finalidade especial projetado no <a name="%_idx_84" id="%_idx_84"/>MIT Artificial Intelligence Laboratory para executar o Lisp com muita eficiência. O dialeto Lisp usado neste livro, chamado <a name="%_idx_86" id="%_idx_86"/>Scheme (Steele 1975), foi inventado em 1975 por <a name="%_idx_88" id="%_idx_88"/><a name="%_idx_90" id="%_idx_90"/>Guy Lewis Steele Jr. e Gerald Jay Sussman, do MIT Artificial Intelligence Laboratory, e posteriormente reimplementado para uso instrucional no MIT. Scheme tornou-se um padrão IEEE em 1990 (IEEE 1990). O dialeto <a name="%_idx_92" id="%_idx_92"/><a name="%_idx_94" id="%_idx_94"/>Common Lisp (Steele 1982, Steele 1990) foi desenvolvido pela comunidade Lisp para combinar recursos dos dialetos Lisp anteriores para criar um padrão industrial para Lisp. O Common Lisp se tornou um padrão ANSI em 1994 (ANSI 1994).</p><p><a name="footnote_Temp_9" href="#call_footnote_Temp_9" id="footnote_Temp_9"><sup><small>3</small></sup></a> Uma dessas aplicações especiais foi um cálculo inovador de importância científica - uma integração do movimento do <a name="%_idx_102" id="%_idx_102"/><a name="%_idx_104" id="%_idx_104"/>Solar Sistema que ampliou os resultados anteriores em quase duas ordens de magnitude e demonstrou que a dinâmica do Sistema Solar é caótica. Essa computação foi possibilitada por novos algoritmos de integração, um compilador de finalidade especial e um computador de finalidade especial implementados com o auxílio de ferramentas de software escritas em Lisp <a name="%_idx_106" id="%_idx_106"/>(Abelson et al. 1992; <a name="%_idx_108" id="%_idx_108"/><a name="%_idx_110" id="%_idx_110"/>Sussman and Wisdom 1992).</p></div>



</body>
</html>