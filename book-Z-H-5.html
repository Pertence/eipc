<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta http-equiv="Content-Type: text/html; charset=utf-8"/>
    <title>Estrutura e Interpretação de Programas de Computador</title>
    <link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default"/>
  </head>
  <body>



<a name="%_chap_Temp_2" id="%_chap_Temp_2"/>
<h1 class="chapter">
<div class="chapterheading"> </div></h1><p>
<a href="book-Z-H-4.html#%_toc_%_chap_Temp_2">Prefácio</a></p><p>Educadores, generais, nutricionistas, psicólogos e pais. Exércitos, estudantes e algumas sociedades são programados. Um ataque a grandes problemas emprega uma sucessão de programas, a maioria dos quais surge no caminho. Esses programas estão repletos de questões que parecem específicas do problema em questão. Para apreciar a programação como uma atividade intelectual por si só, você deve recorrer à programação de computadores; você deve ler e escrever programas de computador - muitos deles. Não importa muito sobre o que são os programas ou quais aplicativos eles servem. O que importa é como eles se saem bem e como se encaixam com outros programas na criação de programas ainda maiores. O programador deve buscar a perfeição da peça e a adequação da coleção. Neste livro, o uso de “programa” é focado na criação, execução e estudo de programas escritos em um dialeto do Lisp para execução em um computador digital. Usando o Lisp, restringimos ou limitamos não o que podemos programar, mas apenas a notação para as descrições de nossos programas.</p><p>Nosso tráfego com o assunto deste livro envolve três focos de fenômenos: a mente humana, coleções de programas de computador e o computador. Todo programa de computador é um modelo, traçado na mente, de um processo real ou mental. Esses processos, decorrentes da experiência e do pensamento humano, são enormes em número, intricados em detalhes e a qualquer momento apenas parcialmente compreendidos. Eles são modelados para nossa satisfação permanente raramente por nossos programas de computador. Assim, mesmo que nossos programas sejam coleções discretas artesanais de símbolos, mosaicos de funções interligadas, eles evoluem continuamente: os modificamos à medida que nossa percepção do modelo se aprofunda, aumenta, generaliza até que o modelo finalmente atinja um lugar metaestável dentro de outro modelo com o qual nós lutamos. A fonte da alegria associada à programação de computadores é o contínuo desenvolvimento dentro da mente e no computador de mecanismos expressos como programas e a explosão de percepção que eles geram. Se a arte interpreta nossos sonhos, o computador os executa sob o disfarce de programas!</p><p>Por todo o seu poder, o computador é um chefe duro. Seus programas devem estar corretos, e o que queremos dizer deve ser dito com precisão em todos os detalhes. Como em qualquer outra atividade simbólica, nos convencemos da verdade do programa por meio de argumentos. O próprio Lisp pode receber uma semântica (a propósito, outro modelo) e, se a função de um programa puder ser especificada, digamos, em cálculo de predicado, os métodos de prova da lógica podem ser usados ​​para criar um aceitável argumento de correção. Infelizmente, à medida que os programas se tornam grandes e complicados, como quase sempre, a adequação, consistência e correção das próprias especificações ficam sujeitas a dúvidas, de modo que argumentos formais completos de correção raramente acompanham programas grandes. Como os grandes programas crescem dos pequenos, é crucial que desenvolvamos um arsenal de estruturas padrão de programa cuja exatidão tenhamos certeza - as chamamos de expressões idiomáticas - e aprendamos a combiná-las em estruturas maiores usando técnicas organizacionais de valor comprovado. Essas técnicas são tratadas detalhadamente neste livro, e entendê-las é essencial para a participação no empreendimento de Prometeus chamada programação. Mais do que nada, a descoberta e o domínio de técnicas organizacionais poderosas aceleram nossa capacidade de criar programas grandes e significativos. Por outro lado, como escrever programas grandes é muito desgastante, somos estimulados a inventar novos métodos para reduzir a massa de funções e detalhes a serem ajustados em programas grandes.</p><p>Ao contrário dos programas, os computadores devem obedecer às leis da física. Se eles desejam executar rapidamente - alguns nanossegundos por alteração de estado - devem transmitir elétrons apenas a pequenas distâncias (no máximo 1 <small><sup>1</sup>/<small>2</small></small> centímetros) O calor gerado pelo grande número de dispositivos tão concentrados no espaço precisa ser removido. Uma arte de engenharia requintada foi desenvolvida equilibrando entre a multiplicidade de funções e a densidade de dispositivos. De qualquer forma, o hardware sempre opera em um nível mais primitivo do que aquele em que desejamos programar. Os processos que transformam nossos programas Lisp em programas de &quot;máquina&quot; são modelos abstratos que programamos. Seu estudo e criação fornecem uma grande quantidade de informações sobre os programas organizacionais associados à programação de modelos arbitrários. Claro que o próprio computador pode ser modelado. Pense nisso: o comportamento do menor elemento de comutação física é modelado pela mecânica quântica descrita por equações diferenciais cujo comportamento detalhado é capturado por aproximações numéricas representadas em programas de computador executados em computadores compostos por <tt>…</tt>!</p><p>Não é apenas uma questão de conveniência tática identificar separadamente os três focos. Embora, como dizem, tudo esteja na cabeça, essa separação lógica induz uma aceleração do tráfego simbólico entre esses focos cuja riqueza, vitalidade e potencial são excedidos na experiência humana apenas pela evolução da própria vida. Na melhor das hipóteses, as relações entre os focos são metaestáveis. Os computadores nunca são grandes o suficiente ou rápidos o suficiente. Cada avanço na tecnologia de hardware leva a empresas de programação mais massivas, novos princípios organizacionais e um enriquecimento de modelos abstratos. Todo leitor deve se perguntar periodicamente: &quot;Para qual fim?&quot; - mas não pergunte com muita frequência para não deixar passar a diversão de programar para a constipação da filosofia agridoce.</p><p>Entre os programas que escrevemos, alguns (mas nunca o suficiente) desempenham uma função matemática precisa, como classificar ou encontrar o máximo de uma sequência de números, determinar a primalidade ou encontrar a raiz quadrada. Chamamos esses programas de algoritmos, e muito se sabe sobre o seu comportamento ideal, principalmente no que diz respeito aos dois parâmetros importantes do tempo de execução e dos requisitos de armazenamento de dados. Um programador deve adquirir bons algoritmos e expressões idiomáticas. Embora alguns programas resistam a especificações precisas, é responsabilidade do programador estimar e sempre tentar melhorar seu desempenho.</p><p>Lisp é um sobrevivente, tendo sido usado por cerca de um quarto de século. Entre as linguagens de programação ativas, apenas o Fortran teve uma vida útil mais longa. As duas linguagens suportam as necessidades de programação de importantes áreas de aplicação, o Fortran para computação científica e de engenharia e o Lisp para inteligência artificial. Essas duas áreas continuam a ser importantes, e seus programadores são tão dedicados a essas duas linguagens que Lisp e Fortran podem muito bem continuar em uso ativo por, pelo menos, mais um quarto de século.</p><p>Alterações no Lisp. O dialeto Scheme usado neste texto evoluiu do Lisp original e difere do último de várias maneiras importantes, incluindo o escopo estático para ligação de variáveis ​​e permitindo funções produzirem funções como valores. Em sua estrutura semântica, Scheme é tão parecido com Algol 60 quanto com os primeiros Lisps. Algol 60, para nunca mais ser uma linguagem ativa, vive nos genes do Scheme e Pascal. Seria difícil encontrar duas linguagens que são a moeda de comunicação de duas culturas mais diferentes do que aquelas reunidas em torno dessas duas linguagens. Pascal é para a construção de pirâmides - estruturas estáticas imponentes e impressionantes, construídas por exércitos que empurram blocos pesados ​​no lugar. Lisp é para a construção de organismos - estruturas imponentes, de tirar o fôlego e dinâmicas, construídas por esquadrões que encaixam inúmeras flutuações de organismos mais simples. Os princípios organizadores usados ​​são os mesmos nos dois casos, exceto por uma diferença extraordinariamente importante: A funcionalidade exportável irrestritas confiada ao programador Lisp é mais do que uma ordem de magnitude maior que a encontrada nos empreendimentos de Pascal. Os programas Lisp enchem as bibliotecas com funções cujo utilitário transcende o aplicativo que as produziu. A lista, a estrutura de dados nativa do Lisp, é amplamente responsável por esse crescimento de utilidade. A estrutura simples e a aplicabilidade natural das listas são refletidas em funções surpreendentemente não idiossincráticas. Em Pascal, a infinidade de estruturas de dados declaráveis ​​induz uma especialização em funções que inibe e penaliza a cooperação casual. É melhor ter 100 funções operando em uma estrutura de dados do que 10 funções operando em 10 estruturas de dados. Como resultado, a pirâmide deve permanecer inalterada por um milênio; o organismo deve evoluir ou perecer.</p><p>Para ilustrar essa diferença, compare o tratamento de materiais e exercícios deste livro com o de qualquer texto do primeiro curso usando Pascal. Não trabalhe com a ilusão de que este é um texto digerível apenas no MIT, peculiar ao tipo encontrada lá. É exatamente o que deve ser um livro sério sobre programação do Lisp, não importa quem é o aluno ou onde ele é usado.</p><p>Observe que este é um texto sobre programação, diferente da maioria dos livros do Lisp, que são usados ​​como uma preparação para o trabalho em inteligência artificial. Afinal, as preocupações críticas de programação de engenharia de software e inteligência artificial tendem a se unir à medida que os sistemas sob investigação se tornam maiores. Isso explica por que existe um interesse crescente no Lisp fora da inteligência artificial.</p><p>Como seria de esperar de seus objetivos, a pesquisa em inteligência artificial gera muitos problemas significativos de programação. Em outras culturas de programação, essa série de problemas gera novas linguagens. De fato, em qualquer tarefa de programação muito grande, um princípio de organização útil é controlar e isolar o tráfego nos módulos de tarefas através da invenção de linguagens. Essas linguagens tendem a se tornar menos primitivas à medida que se aproxima dos limites do sistema em que nós humanos interagimos com mais frequência. Como resultado, esses sistemas contêm funções complexas de processamento replicadas muitas vezes. Lisp possui uma sintaxe e semântica tão simples que a análise pode ser tratada como uma tarefa elementar. Assim, a tecnologia de análise quase não desempenha nenhum papel nos programas Lisp, e a construção de processadores de linguagem raramente é um impedimento para a taxa de crescimento e mudança de grandes sistemas Lisp. Finalmente, é essa simplicidade de sintaxe e semântica que é responsável pelo ônus e liberdade suportados por todos os programadores do Lisp. Nenhum programa Lisp de qualquer tamanho além de algumas linhas pode ser gravado sem estar saturado com funções irrestritas. Inventar e ajustar; ter birras e reinventar! Brindamos o programador Lisp, que encerra seus pensamentos entre aninhamentos de parênteses.</p><p>

</p><p/><p/><p>

</p><p/><div align="left"><table><tr><td>Alan J. Perlis <br/> New Haven, Connecticut</td></tr></table></div><p>
</p><p>




</p></body>
</html>