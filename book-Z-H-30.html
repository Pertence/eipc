<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:ops="http://www.idpf.org/2007/ops">
<!-- Generated from TeX source by tex2page, v 4o,
     (c) Dorai Sitaram, http://www.cs.rice.edu/~dorai/tex2page -->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta http-equiv="Content-Type: text/html; charset=utf-8"/>
    <title>Estrutura e Interpretação de Programas de Computador</title>
    <link rel="stylesheet" type="text/css" href="book-Z-C.css" title="default"/>
  </head>
  <body>



<a name="%_chap_5" id="%_chap_5"/>
<h1 class="chapter">
<div class="chapterheading"><a href="book-Z-H-4.html#%_toc_%_chap_5">Capítulo 5</a></div></h1><p>
<a href="book-Z-H-4.html#%_toc_%_chap_5">Computando com máquinas de registradores</a></p><p>

</p><p>
</p><div align="right">
<table width="60%"><tr><td>
<span class="epigraph">
<p>Meu objetivo é mostrar que a máquina celestial não é uma espécie de ser divino e vivo, mas uma espécie de mecanismo de relógio (e aquele que acredita que um relógio possui alma atribui a glória do criador ao trabalho), na medida em que quase todos os múltiplos movimentos são causados ​​por uma força mais simples e material, assim como todos os movimentos do relógio são causados ​​por um único peso.</p><p>

<a name="%_idx_5456" id="%_idx_5456"/>Johannes Kepler (carta a Herwart von Hohenburg, 1605)</p><p>

</p></span>
</td></tr></table></div>

<p/><p>Começamos este livro estudando processos e descrevendo processos em termos de procedimentos escritos no Lisp. Para explicar o significado desses procedimentos, utilizamos uma sucessão de modelos de avaliação: o modelo de substituição do capítulo 1, o modelo de ambiente do capítulo 3 e o avaliador metacircular do capítulo 4. Nosso exame do avaliador metacircular, em particular, dissipou grande parte do mistério de como as linguagens do tipo Lisp são interpretadas. Mas mesmo o avaliador metacircular deixa perguntas importantes sem resposta, porque falha em elucidar os mecanismos de controle em um sistema Lisp. Por exemplo, o avaliador não explica como a avaliação de uma subexpressão consegue retornar um valor à expressão que usa esse valor, nem explica como alguns procedimentos recursivos geram processos iterativos (ou seja, são avaliados usando espaço constante), enquanto outros procedimentos recursivos geram processos recursivos. Essas perguntas permanecem sem resposta porque o avaliador metacircular é um programa Lisp e, portanto, herda a estrutura de controle do sistema Lisp subjacente. Para fornecer uma descrição mais completa da estrutura de controle do avaliador Lisp, devemos trabalhar em um nível mais primitivo que o próprio Lisp.</p><p>Neste capítulo, descreveremos processos em termos da operação passo a passo de um computador tradicional. Esse computador, ou <a name="%_idx_5458" id="%_idx_5458"/><em>máquina de registradores</em>, executa sequencialmente <em>instruções</em> que manipulam o conteúdo de um conjunto fixo de elementos de armazenamento chamado <a name="%_idx_5460" id="%_idx_5460"/><em>registradores</em>. Uma instrução típica de máquina de registradores aplica uma operação primitiva ao conteúdo de alguns registradores e atribui o resultado a outro registrador. Nossas descrições de processos executados por máquinas de registrador se parecerão muito com programas de “linguagem de máquina” para computadores tradicionais. No entanto, em vez de focar na linguagem da máquina de qualquer computador em particular, examinaremos vários procedimentos do Lisp e projetaremos uma máquina de registradores específica para executar cada procedimento. Assim, abordaremos nossa tarefa da perspectiva de um arquiteto de hardware, e não de um programador de computador em linguagem de máquina. Ao projetar máquinas de registrador, desenvolveremos mecanismos para implementar importantes construções de programação, como recursão. Também apresentaremos uma linguagem para descrever projetos para máquinas de registrador. Na seção <a href="book-Z-H-32.html#%_sec_5.2">5.2</a>, implementaremos um programa Lisp que usa essas descrições para simular as máquinas que projetamos.</p><p>A maioria das operações primitivas de nossas máquinas de registrador são muito simples. Por exemplo, uma operação pode adicionar os números buscados em dois registradores, produzindo um resultado para ser armazenado em um terceiro registrador. Essa operação pode ser realizada por um hardware facilmente descrito. No entanto, para lidar com a estrutura da lista, também usaremos as operações de memória <tt>car</tt>, <tt>cdr</tt>, e <tt>cons</tt>, que exigem um elaborado mecanismo de alocação de armazenamento. Na seção <a href="book-Z-H-33.html#%_sec_5.3">5.3</a>, estudamos sua implementação em termos de operações mais elementares.</p><p>Na seção <a href="book-Z-H-34.html#%_sec_5.4">5.4</a>, após termos acumulado experiência na formulação de procedimentos simples como máquinas de registrador, projetaremos uma máquina que execute o algoritmo descrito pelo avaliador metacircular da seção <a href="book-Z-H-26.html#%_sec_4.1">4.1</a>. Isso preencherá a lacuna no nosso entendimento de como as expressões do Scheme são interpretadas, fornecendo um modelo explícito para os mecanismos de controle no avaliador. Na seção <a href="book-Z-H-35.html#%_sec_5.5">5.5</a>, estudaremos um compilador simples que traduz programas do Scheme em sequências de instruções que podem ser executadas diretamente com os registradores e operações da máquina de registradores do avaliador.</p><p>




</p></body>
</html>